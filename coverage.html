
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>caching: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cryanbrow/eve-graphql-go/graph/caching/memory_cache.go (0.0%)</option>
				
				<option value="file1">github.com/cryanbrow/eve-graphql-go/graph/caching/redis_cache.go (0.0%)</option>
				
				<option value="file2">github.com/cryanbrow/eve-graphql-go/graph/configuration/app_config.go (0.0%)</option>
				
				<option value="file3">github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/alliance/alliance_rest.go (0.0%)</option>
				
				<option value="file4">github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/character/character_rest.go (0.0%)</option>
				
				<option value="file5">github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/corporation/corporation_rest.go (0.0%)</option>
				
				<option value="file6">github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/dogma/dogma_rest.go (0.0%)</option>
				
				<option value="file7">github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/market/market_rest.go (0.0%)</option>
				
				<option value="file8">github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/universe/universe_rest.go (0.0%)</option>
				
				<option value="file9">github.com/cryanbrow/eve-graphql-go/graph/helpers/rest_helper.go (88.6%)</option>
				
				<option value="file10">github.com/cryanbrow/eve-graphql-go/graph/helpers/time_helper.go (100.0%)</option>
				
				<option value="file11">github.com/cryanbrow/eve-graphql-go/graph/schema.resolvers.go (0.0%)</option>
				
				<option value="file12">github.com/cryanbrow/eve-graphql-go/server.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package caching

import (
        "sync"
        "time"

        log "github.com/sirupsen/logrus"
)

type cacheRecord struct {
        value  []byte
        expiry int64
}

func CheckMemoryCache(key string) (bool, []byte) <span class="cov0" title="0">{
        result, success := Cache.Load(key)
        if !success || result.(cacheRecord).value == nil || result.(cacheRecord).expiry &lt; time.Now().UnixMilli() </span><span class="cov0" title="0">{
                Cache.Delete(key)
                return false, nil
        }</span> else<span class="cov0" title="0"> {
                return true, result.(cacheRecord).value
        }</span>
}

func AddToMemoryCache(key string, value []byte, ttl int64) <span class="cov0" title="0">{
        result, success := Cache.Load(key)
        if !success || result.(cacheRecord).value == nil || result.(cacheRecord).expiry &lt; time.Now().UnixMilli() </span><span class="cov0" title="0">{
                log.Debugf("Adding to Memory Cache: %s", key)
                var record cacheRecord
                record.expiry = ttl + time.Now().UnixMilli()
                record.value = value
                Cache.Store(key, record)
        }</span>
}

var (
        Cache sync.Map
)
</pre>
		
		<pre class="file" id="file1" style="display: none">package caching

import (
        "strconv"
        "time"

        "context"

        "github.com/cryanbrow/eve-graphql-go/graph/configuration"
        "github.com/go-redis/redis/v8"
        log "github.com/sirupsen/logrus"
)

type Client struct {
}

func (c *Client) CheckRedisCache(key string) (bool, []byte) <span class="cov0" title="0">{
        log.Debugf("Checking Redis Cache for key: %s", key)
        val, err := rdb.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == string("redis: nil") </span><span class="cov0" title="0">{
                        return false, nil
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf("Redis encountered an error: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return true, []byte(val)</span>
}

func (c *Client) AddToRedisCache(key string, value []byte, ttl int64) <span class="cov0" title="0">{
        log.Debugf("Adding to Redis Cache: %s", key)
        ttlString, err := time.ParseDuration((strconv.FormatInt(ttl, 10) + "ms"))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to parse TTL: %v ", err)
                return
        }</span>
        <span class="cov0" title="0">_, err = rdb.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == string("redis: nil") </span><span class="cov0" title="0">{
                        status := rdb.Set(ctx, key, value, ttlString)
                        statusText, _ := status.Result()
                        log.Debugf("status text: %s", statusText)
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf("Redis encountered an error: %v", err)
                }</span>
        }
}

func ConfigureRedisClient() <span class="cov0" title="0">{
        rdb = redis.NewClient(&amp;redis.Options{
                Addr:     configuration.AppConfig.Redis.Url + ":" + configuration.AppConfig.Redis.Port,
                Username: configuration.AppConfig.Redis.User,
                Password: configuration.AppConfig.Redis.Password,
                DB:       0, // use default DB
        })
}</span>

var (
        ctx context.Context = context.Background()
        rdb *redis.Client
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package configuration

import (
        "os"

        "github.com/kelseyhightower/envconfig"
        log "github.com/sirupsen/logrus"
        "gopkg.in/yaml.v2"
)

const configPath = "config.yml"

var TestConfigPath string

type Config struct {
        Server struct {
                Port string `yaml:"port"`
        }
        Redis struct {
                Url      string `yaml:"url"`
                Port     string `yaml:"port"`
                User     string `yaml:"user"`
                Password string `yaml:"password"`
        } `yaml:"redis"`
        Esi struct {
                Default struct {
                        Query_params []Key_value `yaml:"query_params"`
                        Url          string      `yaml:"url"`
                } `yaml:"default"`
        } `yaml:"esi"`
}

type Key_value struct {
        Key   string `yaml:"key"`
        Value string `yaml:"value"`
}

var AppConfig Config

func ReadFile() <span class="cov0" title="0">{
        var file *os.File
        var err error
        if TestConfigPath == "" </span><span class="cov0" title="0">{
                file, err = os.Open(configPath)
        }</span> else<span class="cov0" title="0"> {
                log.Debug("test config path is populated")
                file, err = os.Open(TestConfigPath)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                processError(err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        decoder := yaml.NewDecoder(file)
        err = decoder.Decode(&amp;AppConfig)
        if err != nil </span><span class="cov0" title="0">{
                processError(err)
        }</span>
}

func ReadEnv() <span class="cov0" title="0">{
        err := envconfig.Process("", &amp;AppConfig)
        if err != nil </span><span class="cov0" title="0">{
                processError(err)
        }</span>
}

func processError(err error) <span class="cov0" title="0">{
        log.Errorf("Could not load config. : %v", err)
        os.Exit(2)
}</span>

func SetupLogging() <span class="cov0" title="0">{
        log.SetFormatter(&amp;log.JSONFormatter{})
        log.SetLevel(log.DebugLevel)
        log.SetReportCaller(true)
}</span>

func LoadConfiguration() <span class="cov0" title="0">{
        SetupLogging()
        ReadFile()
        ReadEnv()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package alliance

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"

        "github.com/cryanbrow/eve-graphql-go/graph/configuration"
        "github.com/cryanbrow/eve-graphql-go/graph/generated/model"
        "github.com/cryanbrow/eve-graphql-go/graph/helpers"
        log "github.com/sirupsen/logrus"
)

func AllianceByID(id *int) (*model.Alliance, error) <span class="cov0" title="0">{
        var alliance *model.Alliance = new(model.Alliance)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/alliances/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "AllianceByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return alliance, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;alliance); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return alliance, err
        }</span>

        <span class="cov0" title="0">return alliance, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package character

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"

        "github.com/cryanbrow/eve-graphql-go/graph/configuration"
        "github.com/cryanbrow/eve-graphql-go/graph/generated/model"
        "github.com/cryanbrow/eve-graphql-go/graph/helpers"
        log "github.com/sirupsen/logrus"
)

func CharacterByID(id *int) (*model.Character, error) <span class="cov0" title="0">{
        var character *model.Character = new(model.Character)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/characters/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "CharacterByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return character, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;character); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return character, err
        }</span>

        <span class="cov0" title="0">return character, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package corporation

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"

        "github.com/cryanbrow/eve-graphql-go/graph/configuration"
        "github.com/cryanbrow/eve-graphql-go/graph/generated/model"
        "github.com/cryanbrow/eve-graphql-go/graph/helpers"
        log "github.com/sirupsen/logrus"
)

func CorporationByID(id *int) (*model.Corporation, error) <span class="cov0" title="0">{
        var corporation *model.Corporation = new(model.Corporation)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/corporations/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "CorporationByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return corporation, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;corporation); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return corporation, err
        }</span>

        <span class="cov0" title="0">return corporation, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package dogma

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"

        "github.com/cryanbrow/eve-graphql-go/graph/configuration"
        "github.com/cryanbrow/eve-graphql-go/graph/generated/model"
        "github.com/cryanbrow/eve-graphql-go/graph/helpers"
        log "github.com/sirupsen/logrus"
)

func DogmaAttributeByID(id *int) (*model.DogmaAttributeDetail, error) <span class="cov0" title="0">{
        var dogmaAttribute *model.DogmaAttributeDetail = new(model.DogmaAttributeDetail)
        if id == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/dogma/attributes/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "DogmaAttributeByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return dogmaAttribute, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;dogmaAttribute); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return dogmaAttribute, err
        }</span>

        <span class="cov0" title="0">return dogmaAttribute, nil</span>
}

func DogmaEffectByID(id *int) (*model.DogmaEffectDetail, error) <span class="cov0" title="0">{
        var dogmaEffect *model.DogmaEffectDetail = new(model.DogmaEffectDetail)
        if id == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/dogma/effects/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "DogmaEffectByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return dogmaEffect, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;dogmaEffect); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return dogmaEffect, err
        }</span>

        <span class="cov0" title="0">return dogmaEffect, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package market

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"

        "github.com/cryanbrow/eve-graphql-go/graph/configuration"
        "github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/universe"
        model "github.com/cryanbrow/eve-graphql-go/graph/generated/model"
        "github.com/cryanbrow/eve-graphql-go/graph/helpers"
        local_model "github.com/cryanbrow/eve-graphql-go/graph/model"
        log "github.com/sirupsen/logrus"
)

func MarketGroupByID(id *int) (*model.MarketGroup, error) <span class="cov0" title="0">{
        var marketGroup *model.MarketGroup = new(model.MarketGroup)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/markets/groups/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "MarketGroupByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return marketGroup, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;marketGroup); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return marketGroup, err
        }</span>

        <span class="cov0" title="0">return marketGroup, nil</span>
}

func OrdersForRegion(regionID *int, orderType *model.Ordertype, typeID *int, page *int) (*model.OrderWrapper, error) <span class="cov0" title="0">{
        log.WithFields(log.Fields{"regionID": regionID, "typeID": typeID, "orderType": orderType}).Info("OrdersForRegion Called")
        orderList := make([]*model.Order, 0)
        base_url := fmt.Sprintf("%s/markets/%s/orders/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*regionID))

        redis_key := "OrdersForRegion:" + strconv.Itoa(*regionID) + ":" + orderType.String()

        query_params := make([]configuration.Key_value, 2)
        kv := new(configuration.Key_value)
        kv.Key = "page"
        kv.Value = strconv.Itoa(*page)
        query_params = append(query_params, *kv)

        if typeID != nil </span><span class="cov0" title="0">{
                redis_key = redis_key + ":" + strconv.Itoa(*typeID)
                kv.Key = "type_id"
                kv.Value = strconv.Itoa(*typeID)
                query_params = append(query_params, *kv)
        }</span>

        <span class="cov0" title="0">redis_key = redis_key + ":" + strconv.Itoa(*page)

        orderResult, pages, err := ordersForRegionREST(base_url, query_params, redis_key)

        if err == nil </span><span class="cov0" title="0">{
                orderList = append(orderList, orderResult...)
        }</span> else<span class="cov0" title="0"> {
                log.WithFields(log.Fields{"regionID": regionID, "typeID": typeID, "orderType": orderType}).Errorf("First page query for Orders has error : %v", err)
                println(err)
        }</span>

        <span class="cov0" title="0">return_orders := new(model.OrderWrapper)
        return_orders.List = orderList
        return_orders.Xpages = &amp;pages

        return return_orders, nil</span>
}

func OrdersForRegionByName(region *string, orderType *model.Ordertype, typeName *string, page *int) (*model.OrderWrapper, error) <span class="cov0" title="0">{
        regionID, err := universe.IdForName(region, local_model.REGIONS)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("unknown name for region")
        }</span>
        <span class="cov0" title="0">typeID, err := universe.IdForName(typeName, local_model.INVENTORY_TYPES)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("unknown name for typeName")
        }</span>
        <span class="cov0" title="0">orders, err := OrdersForRegion(&amp;regionID, orderType, &amp;typeID, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return orders, nil</span>
}

func ordersForRegionREST(url string, additional_query_params []configuration.Key_value, redis_key string) ([]*model.Order, int, error) <span class="cov0" title="0">{
        var orders []*model.Order
        var pages = 0
        var buffer bytes.Buffer
        responseBytes, header, err := helpers.MakeCachingRESTCall(url, http.MethodGet, buffer, additional_query_params, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return orders, 0, err
        }</span>

        <span class="cov0" title="0">pages, _ = strconv.Atoi(header.Get("x-pages"))

        if err := json.Unmarshal(responseBytes, &amp;orders); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"url": url}).Errorf("Could not unmarshal reponseBytes. : %v", err.Error())
                return orders, 0, err
        }</span>

        <span class="cov0" title="0">return orders, pages, nil</span>
}

func OrderHistory(regionID *int, typeID *int) ([]*model.OrderHistory, error) <span class="cov0" title="0">{
        if regionID == nil || typeID == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">var orderHistory []*model.OrderHistory = make([]*model.OrderHistory, 0)
        base_url := fmt.Sprintf("%s/markets/%s/history", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*regionID))
        redis_key := "OrderHistoryByID:" + strconv.Itoa(*regionID) + ":" + strconv.Itoa(*typeID)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return orderHistory, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;orderHistory); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"regionID": regionID, "typeID": typeID}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return orderHistory, err
        }</span>

        <span class="cov0" title="0">return orderHistory, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package universe

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"

        "github.com/cryanbrow/eve-graphql-go/graph/caching"
        "github.com/cryanbrow/eve-graphql-go/graph/configuration"
        model "github.com/cryanbrow/eve-graphql-go/graph/generated/model"
        "github.com/cryanbrow/eve-graphql-go/graph/helpers"
        local_model "github.com/cryanbrow/eve-graphql-go/graph/model"
        log "github.com/sirupsen/logrus"
)

func AncestryByID(id *int) (*model.Ancestry, error) <span class="cov0" title="0">{
        var ancestry *model.Ancestry = new(model.Ancestry)
        var err error
        if id == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">inCache, result := Redis_client.CheckRedisCache("AncestryByID:" + strconv.Itoa(*id))
        if !inCache </span><span class="cov0" title="0">{
                ancestry, err = ancestryByArray(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov0" title="0"> {
                        return ancestry, nil
                }</span>
        } else<span class="cov0" title="0"> {
                if err := json.Unmarshal(result, &amp;ancestry); err != nil </span><span class="cov0" title="0">{
                        log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                        return ancestry, err
                }</span> else<span class="cov0" title="0"> {
                        return ancestry, nil
                }</span>
        }
}

func ancestryByArray(id *int) (*model.Ancestry, error) <span class="cov0" title="0">{
        var ancestries []*model.Ancestry = make([]*model.Ancestry, 0)
        var returnAncestry *model.Ancestry
        var redis_key = "AncestryByID:" + strconv.Itoa(*id)
        base_url := fmt.Sprintf("%s/universe/ancestries/", configuration.AppConfig.Esi.Default.Url)

        var buffer bytes.Buffer
        responseBytes, headers, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;ancestries); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, ancestry := range ancestries </span><span class="cov0" title="0">{
                log.Info(*ancestry.Name)
                if *ancestry.ID == *id </span><span class="cov0" title="0">{
                        returnAncestry = ancestry
                        log.Info("Found Ancestry ID")
                }</span>
                <span class="cov0" title="0">ancestryBytes, err := json.Marshal(*ancestry)
                if err == nil </span><span class="cov0" title="0">{
                        Redis_client.AddToRedisCache("AncestryByID:"+strconv.Itoa(*ancestry.ID), ancestryBytes, helpers.ESI_ttl_to_millis(headers.Get("expires")))
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf("Failure Marshalling: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return returnAncestry, nil</span>
}

func AsteroidBeltDetails(asteroidBelts []*int) ([]*model.AsteroidBelt, error) <span class="cov0" title="0">{
        asteroidBeltDetails := make([]*model.AsteroidBelt, 0)
        for _, element := range asteroidBelts </span><span class="cov0" title="0">{
                asteroidBelt, err := AsteroidBeltByID(element)
                if err == nil </span><span class="cov0" title="0">{
                        asteroidBeltDetails = append(asteroidBeltDetails, asteroidBelt)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">log.Debug(len(asteroidBeltDetails))
        return asteroidBeltDetails, nil</span>
}

func AsteroidBeltByID(id *int) (*model.AsteroidBelt, error) <span class="cov0" title="0">{
        var asteroidBelt *model.AsteroidBelt = new(model.AsteroidBelt)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/asteroid_belts/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "AsteroidBeltByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return asteroidBelt, err
        }</span>
        <span class="cov0" title="0">log.Debug(string(responseBytes))

        if err := json.Unmarshal(responseBytes, &amp;asteroidBelt); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return asteroidBelt, err
        }</span>
        <span class="cov0" title="0">log.Debug(*asteroidBelt.Name)

        return asteroidBelt, nil</span>
}

func BloodlineByID(id *int) (*model.Bloodline, error) <span class="cov0" title="0">{
        var bloodline *model.Bloodline = new(model.Bloodline)
        var err error
        if id == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">inCache, result := Redis_client.CheckRedisCache("BloodlineByID:" + strconv.Itoa(*id))
        if !inCache </span><span class="cov0" title="0">{
                bloodline, err = bloodlineByArray(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov0" title="0"> {
                        return bloodline, nil
                }</span>
        } else<span class="cov0" title="0"> {
                if err := json.Unmarshal(result, &amp;bloodline); err != nil </span><span class="cov0" title="0">{
                        log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                        return bloodline, err
                }</span> else<span class="cov0" title="0"> {
                        return bloodline, nil
                }</span>
        }
}

func bloodlineByArray(id *int) (*model.Bloodline, error) <span class="cov0" title="0">{
        var bloodlines []*model.Bloodline = make([]*model.Bloodline, 0)
        var returnBloodline *model.Bloodline
        base_url := fmt.Sprintf("%s/universe/bloodlines/", configuration.AppConfig.Esi.Default.Url)
        redis_key := "BloodlineByID"

        var buffer bytes.Buffer
        responseBytes, headers, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;bloodlines); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, bloodline := range bloodlines </span><span class="cov0" title="0">{
                log.Info(*bloodline.Name)
                if *bloodline.BloodlineID == *id </span><span class="cov0" title="0">{
                        returnBloodline = bloodline
                        log.Info("Found Bloodline ID")
                }</span>
                <span class="cov0" title="0">bloodlineBytes, err := json.Marshal(*bloodline)
                if err == nil </span><span class="cov0" title="0">{
                        Redis_client.AddToRedisCache("BloodlineByID:"+strconv.Itoa(*bloodline.BloodlineID), bloodlineBytes, helpers.ESI_ttl_to_millis(headers.Get("expires")))
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf("Failure Marshalling: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return returnBloodline, nil</span>
}

func CategoryByID(id *int) (*model.Category, error) <span class="cov0" title="0">{
        var category *model.Category = new(model.Category)
        if id == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/categories/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "CategoryByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return category, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;category); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return category, err
        }</span>

        <span class="cov0" title="0">return category, nil</span>
}

func ConstellationsByIDs(ids []*int) ([]*model.Constellation, error) <span class="cov0" title="0">{
        constellationDetails := make([]*model.Constellation, 0)
        for _, element := range ids </span><span class="cov0" title="0">{
                constellation, err := ConstellationByID(element)
                if err == nil </span><span class="cov0" title="0">{
                        constellationDetails = append(constellationDetails, constellation)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return constellationDetails, nil</span>
}

func ConstellationByID(id *int) (*model.Constellation, error) <span class="cov0" title="0">{
        var constellation *model.Constellation = new(model.Constellation)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/constellations/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "ConstellationByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return constellation, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;constellation); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return constellation, err
        }</span>

        <span class="cov0" title="0">return constellation, nil</span>
}

func FactionByID(id *int) (*model.Faction, error) <span class="cov0" title="0">{
        var faction *model.Faction = new(model.Faction)
        if id == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">inCache, result := Redis_client.CheckRedisCache("FactionByID:" + strconv.Itoa(*id))
        if !inCache </span><span class="cov0" title="0">{
                faction, err := factionByArray(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov0" title="0"> {
                        return faction, nil
                }</span>
        } else<span class="cov0" title="0"> {
                if err := json.Unmarshal(result, &amp;faction); err != nil </span><span class="cov0" title="0">{
                        log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                        return faction, err
                }</span> else<span class="cov0" title="0"> {
                        return faction, nil
                }</span>
        }
}

func factionByArray(id *int) (*model.Faction, error) <span class="cov0" title="0">{
        var factions []*model.Faction = make([]*model.Faction, 0)
        var returnFaction *model.Faction
        base_url := fmt.Sprintf("%s/universe/factions/", configuration.AppConfig.Esi.Default.Url)
        redis_key := "FactionByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, headers, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;factions); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, faction := range factions </span><span class="cov0" title="0">{
                log.Info(*faction.Name)
                if *faction.FactionID == *id </span><span class="cov0" title="0">{
                        returnFaction = faction
                        log.Info("Found Faction ID")
                }</span>
                <span class="cov0" title="0">factionBytes, err := json.Marshal(*faction)
                if err == nil </span><span class="cov0" title="0">{
                        Redis_client.AddToRedisCache("FactionByID:"+strconv.Itoa(*faction.FactionID), factionBytes, helpers.ESI_ttl_to_millis(headers.Get("expires")))
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf("Failure Marshalling: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return returnFaction, nil</span>
}

func GraphicByID(id *int) (*model.Graphic, error) <span class="cov0" title="0">{
        var graphic *model.Graphic = new(model.Graphic)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/graphics/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "GraphicByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return graphic, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;graphic); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return graphic, err
        }</span>

        <span class="cov0" title="0">return graphic, nil</span>
}

func GroupByID(id *int) (*model.Group, error) <span class="cov0" title="0">{
        var group *model.Group = new(model.Group)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/groups/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "GroupByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return group, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;group); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return group, err
        }</span>

        <span class="cov0" title="0">return group, nil</span>
}

func IdForName(name *string, name_type string) (int, error) <span class="cov0" title="0">{
        var ids *local_model.Names = new(local_model.Names)
        base_url := fmt.Sprintf("%s/universe/ids/", configuration.AppConfig.Esi.Default.Url)
        if name == nil </span><span class="cov0" title="0">{
                return 0, errors.New("nil name")
        }</span>
        <span class="cov0" title="0">redis_key := "IDForName:" + *name
        singleItemArray := []string{*name}

        var buf bytes.Buffer
        err := json.NewEncoder(&amp;buf).Encode(singleItemArray)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return 0, err
        }</span>

        <span class="cov0" title="0">responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodPost, buf, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;ids); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"name": *name}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return 0, err
        }</span>

        <span class="cov0" title="0">switch name_type </span>{
        case local_model.AGENTS:<span class="cov0" title="0">
                return *ids.Agents[0].ID, nil</span>
        case local_model.ALLIANCES:<span class="cov0" title="0">
                return *ids.Alliances[0].ID, nil</span>
        case local_model.CHARACTERS:<span class="cov0" title="0">
                return *ids.Characters[0].ID, nil</span>
        case local_model.CONSTELLATIONS:<span class="cov0" title="0">
                return *ids.Constellations[0].ID, nil</span>
        case local_model.CORPORATIONS:<span class="cov0" title="0">
                return *ids.Corporations[0].ID, nil</span>
        case local_model.FACTIONS:<span class="cov0" title="0">
                return *ids.Factions[0].ID, nil</span>
        case local_model.INVENTORY_TYPES:<span class="cov0" title="0">
                return *ids.InventoryTypes[0].ID, nil</span>
        case local_model.REGIONS:<span class="cov0" title="0">
                return *ids.Regions[0].ID, nil</span>
        case local_model.SYSTEMS:<span class="cov0" title="0">
                return *ids.Systems[0].ID, nil</span>
        default:<span class="cov0" title="0">
                return 0, errors.New("all fields nil")</span>
        }

}

func ItemTypesByIDs(itemTypes []*int) ([]*model.ItemType, error) <span class="cov0" title="0">{
        itemTypeDetails := make([]*model.ItemType, 0)
        for _, element := range itemTypes </span><span class="cov0" title="0">{
                itemType, err := ItemTypeByID(element)
                if err == nil </span><span class="cov0" title="0">{
                        itemTypeDetails = append(itemTypeDetails, itemType)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return itemTypeDetails, nil</span>
}

func ItemTypeByID(id *int) (*model.ItemType, error) <span class="cov0" title="0">{
        var itemType *model.ItemType = new(model.ItemType)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/types/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "ItemTypeByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return itemType, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;itemType); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return itemType, err
        }</span>

        <span class="cov0" title="0">return itemType, nil</span>
}

func MoonDetails(moons []*int) ([]*model.Moon, error) <span class="cov0" title="0">{
        moonDetails := make([]*model.Moon, 0)
        for _, element := range moons </span><span class="cov0" title="0">{
                moon, err := MoonByID(element)
                if err == nil </span><span class="cov0" title="0">{
                        moonDetails = append(moonDetails, moon)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return moonDetails, nil</span>
}

func MoonByID(id *int) (*model.Moon, error) <span class="cov0" title="0">{
        var moon *model.Moon = new(model.Moon)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/moons/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "MoonByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return moon, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;moon); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return moon, err
        }</span>

        <span class="cov0" title="0">return moon, nil</span>
}

func PlanetByID(id *int) (*model.Planet, error) <span class="cov0" title="0">{
        var planet *model.Planet = new(model.Planet)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/planets/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "PlanetByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return planet, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;planet); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return planet, err
        }</span>

        <span class="cov0" title="0">return planet, nil</span>
}

func RaceByID(id *int) (*model.Race, error) <span class="cov0" title="0">{
        var race *model.Race = new(model.Race)
        var err error
        if id == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">inCache, result := Redis_client.CheckRedisCache("RaceByID:" + strconv.Itoa(*id))
        if !inCache </span><span class="cov0" title="0">{
                race, err = raceByArray(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov0" title="0"> {
                        return race, nil
                }</span>
        } else<span class="cov0" title="0"> {
                if err := json.Unmarshal(result, &amp;race); err != nil </span><span class="cov0" title="0">{
                        log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                        return race, err
                }</span> else<span class="cov0" title="0"> {
                        return race, nil
                }</span>
        }
}

func raceByArray(id *int) (*model.Race, error) <span class="cov0" title="0">{
        var races []*model.Race = make([]*model.Race, 0)
        var returnRace *model.Race
        var headers http.Header = nil
        base_url := fmt.Sprintf("%s/universe/races/", configuration.AppConfig.Esi.Default.Url)
        redis_key := "RaceByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, headers, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;races); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, race := range races </span><span class="cov0" title="0">{
                log.Info(*race.Name)
                if *race.RaceID == *id </span><span class="cov0" title="0">{
                        returnRace = race
                        log.Info("Found Race ID")
                }</span>
                <span class="cov0" title="0">raceBytes, err := json.Marshal(*race)
                if err == nil </span><span class="cov0" title="0">{
                        Redis_client.AddToRedisCache("RaceByID:"+strconv.Itoa(*race.RaceID), raceBytes, helpers.ESI_ttl_to_millis(headers.Get("expires")))
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf("Failure Marshalling: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return returnRace, nil</span>
}

func RegionByID(id *int) (*model.Region, error) <span class="cov0" title="0">{
        var region *model.Region = new(model.Region)
        if id == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/regions/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "RegionByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return region, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;region); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return region, err
        }</span>

        <span class="cov0" title="0">return region, nil</span>
}

func StarByID(id *int) (*model.Star, error) <span class="cov0" title="0">{
        var star *model.Star = new(model.Star)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/stars/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "StarByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return star, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;star); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return star, err
        }</span>

        <span class="cov0" title="0">return star, nil</span>
}

func StargateDetails(stargates []*int) ([]*model.Stargate, error) <span class="cov0" title="0">{
        stargateDetails := make([]*model.Stargate, 0)
        for _, element := range stargates </span><span class="cov0" title="0">{
                stargate, err := StargateByID(element)
                if err == nil </span><span class="cov0" title="0">{
                        stargateDetails = append(stargateDetails, stargate)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return stargateDetails, nil</span>
}

func StargateByID(id *int) (*model.Stargate, error) <span class="cov0" title="0">{
        var stargate *model.Stargate = new(model.Stargate)
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">base_url := fmt.Sprintf("%s/universe/stargates/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "StargateByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return stargate, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;stargate); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return stargate, err
        }</span>

        <span class="cov0" title="0">return stargate, nil</span>
}

func StationByArray(ids []*int) ([]*model.Station, error) <span class="cov0" title="0">{
        stationDetails := make([]*model.Station, 0)
        for _, element := range ids </span><span class="cov0" title="0">{
                station, err := StationByID(element)
                if err == nil </span><span class="cov0" title="0">{
                        stationDetails = append(stationDetails, station)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return stationDetails, nil</span>
}

func StationByID(id *int) (*model.Station, error) <span class="cov0" title="0">{
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">if *id &gt; 2147483647 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">var station *model.Station = new(model.Station)
        base_url := fmt.Sprintf("%s/universe/stations/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "StationByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return station, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;station); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return station, err
        }</span>

        <span class="cov0" title="0">return station, nil</span>
}

func SystemByArray(ids []*int) ([]*model.System, error) <span class="cov0" title="0">{
        systemDetails := make([]*model.System, 0)
        for _, element := range ids </span><span class="cov0" title="0">{
                system, err := SystemByID(element)
                if err == nil </span><span class="cov0" title="0">{
                        systemDetails = append(systemDetails, system)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return systemDetails, nil</span>
}

func SystemByID(id *int) (*model.System, error) <span class="cov0" title="0">{
        if id == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil id")
        }</span>
        <span class="cov0" title="0">var system *model.System = new(model.System)
        base_url := fmt.Sprintf("%s/universe/systems/%s/", configuration.AppConfig.Esi.Default.Url, strconv.Itoa(*id))
        redis_key := "SystemByID:" + strconv.Itoa(*id)

        var buffer bytes.Buffer
        responseBytes, _, err := helpers.MakeCachingRESTCall(base_url, http.MethodGet, buffer, nil, redis_key)
        if err != nil </span><span class="cov0" title="0">{
                return system, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(responseBytes, &amp;system); err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{"id": id}).Errorf("Could not unmarshal reponseBytes. %v", err)
                return system, err
        }</span>

        <span class="cov0" title="0">return system, nil</span>
}

type RedisClient interface {
        AddToRedisCache(key string, value []byte, ttl int64)
        CheckRedisCache(key string) (bool, []byte)
}

var (
        Redis_client RedisClient
)

func SetupUniverseRest() <span class="cov0" title="0">{
        Redis_client = &amp;caching.Client{}
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package helpers

import (
        "bytes"
        "errors"
        "io/ioutil"
        "net/http"
        "net/url"

        cache "github.com/cryanbrow/eve-graphql-go/graph/caching"
        "github.com/cryanbrow/eve-graphql-go/graph/configuration"
        log "github.com/sirupsen/logrus"
)

func MakeCachingRESTCall(base_url string, verb string, body bytes.Buffer, additional_query_params []configuration.Key_value, redis_query_key string) ([]byte, http.Header, error) <span class="cov7" title="8">{
        inCache, result := Redis_client.CheckRedisCache(redis_query_key)
        if !inCache </span><span class="cov7" title="7">{
                crest_url, err := url.Parse(base_url)
                if err != nil </span><span class="cov1" title="1">{
                        log.WithFields(log.Fields{"base_url": base_url, "verb": verb}).Errorf("Failed to Parse URL with Error : %v", err)
                        return nil, nil, err
                }</span>
                <span class="cov6" title="6">queryParameters := crest_url.Query()
                for _, kv := range configuration.AppConfig.Esi.Default.Query_params </span><span class="cov10" title="15">{
                        queryParameters.Add(kv.Key, kv.Value)
                }</span>
                <span class="cov6" title="6">for _, kv := range additional_query_params </span><span class="cov4" title="3">{
                        queryParameters.Add(kv.Key, kv.Value)
                }</span>

                <span class="cov6" title="6">crest_url.RawQuery = queryParameters.Encode()
                url := crest_url.String()

                log.WithFields(log.Fields{"url": url}).Info("Making REST Call")
                request, err := http.NewRequest(verb, url, &amp;body)
                if err != nil </span><span class="cov1" title="1">{
                        log.WithFields(log.Fields{"url": url}).Errorf("Could not build request. : %v", err)
                        return make([]byte, 0), nil, err
                }</span>
                <span class="cov6" title="5">response, err := Client.Do(request)
                if err != nil </span><span class="cov1" title="1">{
                        log.WithFields(log.Fields{"url": url}).Errorf("Could not make request. : %v", err)
                        return make([]byte, 0), nil, err
                }</span>

                <span class="cov5" title="4">h := response.Header
                responseBytes, err := ioutil.ReadAll(response.Body)
                if response.StatusCode != 200 </span><span class="cov1" title="1">{
                        log.WithFields(log.Fields{"url": url, "status_code": response.StatusCode}).Errorf("Received bad status code. : %v", err)
                        return make([]byte, 0), nil, errors.New(response.Status)
                }</span>
                <span class="cov4" title="3">if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(log.Fields{"url": url}).Errorf("Could not read response for body. : %v", err)
                        return make([]byte, 0), nil, err
                }</span>
                <span class="cov4" title="3">Redis_client.AddToRedisCache(redis_query_key, responseBytes, ESI_ttl_to_millis(h.Get("expires")))
                return responseBytes, h, nil</span>
        }
        <span class="cov1" title="1">return result, nil, nil</span>
}

type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

type RedisClient interface {
        AddToRedisCache(key string, value []byte, ttl int64)
        CheckRedisCache(key string) (bool, []byte)
}

var (
        Client       HTTPClient
        Redis_client RedisClient
)

func SetupRestHelper() <span class="cov0" title="0">{
        Client = &amp;http.Client{}
        Redis_client = &amp;cache.Client{}
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package helpers

import (
        "strconv"
        "time"

        log "github.com/sirupsen/logrus"
)

func ESI_ttl_to_millis(esi_time string) int64 <span class="cov10" title="5">{
        log.WithFields(log.Fields{"time": esi_time}).Debugf("Parsing Time : %s", esi_time)
        t, err := time.Parse(time.RFC1123, esi_time)
        if err != nil </span><span class="cov8" title="4">{
                log.WithFields(log.Fields{"time": esi_time}).Errorf("Failed to Parse Time with Error : %v", err)
                return 43200000
        }</span>

        <span class="cov1" title="1">log.Debugf("Responding with time: %s ", strconv.FormatInt(t.UTC().UnixMilli()-time.Now().UnixMilli(), 10))
        return t.UTC().UnixMilli() - time.Now().UnixMilli()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.

import (
        "context"

        "github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/alliance"
        "github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/character"
        "github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/corporation"
        "github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/dogma"
        "github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/market"
        "github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/universe"
        "github.com/cryanbrow/eve-graphql-go/graph/generated"
        model "github.com/cryanbrow/eve-graphql-go/graph/generated/model"
)

func (r *allianceResolver) CreatorCorporation(ctx context.Context, obj *model.Alliance) (*model.Corporation, error) <span class="cov0" title="0">{
        return corporation.CorporationByID(obj.CreatorCorporationID)
}</span>

func (r *allianceResolver) Creator(ctx context.Context, obj *model.Alliance) (*model.Character, error) <span class="cov0" title="0">{
        return character.CharacterByID(obj.CreatorID)
}</span>

func (r *allianceResolver) ExecutorCorporation(ctx context.Context, obj *model.Alliance) (*model.Corporation, error) <span class="cov0" title="0">{
        return corporation.CorporationByID(obj.ExecutorCorporationID)
}</span>

func (r *allianceResolver) Faction(ctx context.Context, obj *model.Alliance) (*model.Faction, error) <span class="cov0" title="0">{
        return universe.FactionByID(obj.FactionID)
}</span>

func (r *ancestryResolver) Bloodline(ctx context.Context, obj *model.Ancestry) (*model.Bloodline, error) <span class="cov0" title="0">{
        return universe.BloodlineByID(obj.BloodlineID)
}</span>

func (r *asteroid_beltResolver) System(ctx context.Context, obj *model.AsteroidBelt) (*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByID(obj.SystemID)
}</span>

func (r *characterResolver) Alliance(ctx context.Context, obj *model.Character) (*model.Alliance, error) <span class="cov0" title="0">{
        return alliance.AllianceByID(obj.AllianceID)
}</span>

func (r *characterResolver) Ancestry(ctx context.Context, obj *model.Character) (*model.Ancestry, error) <span class="cov0" title="0">{
        return universe.AncestryByID(obj.AncestryID)
}</span>

func (r *characterResolver) Bloodline(ctx context.Context, obj *model.Character) (*model.Bloodline, error) <span class="cov0" title="0">{
        return universe.BloodlineByID(obj.BloodlineID)
}</span>

func (r *characterResolver) Corporation(ctx context.Context, obj *model.Character) (*model.Corporation, error) <span class="cov0" title="0">{
        return corporation.CorporationByID(obj.CorporationID)
}</span>

func (r *characterResolver) Faction(ctx context.Context, obj *model.Character) (*model.Faction, error) <span class="cov0" title="0">{
        return universe.FactionByID(obj.FactionID)
}</span>

func (r *characterResolver) Race(ctx context.Context, obj *model.Character) (*model.Race, error) <span class="cov0" title="0">{
        return universe.RaceByID(obj.RaceID)
}</span>

func (r *constellationResolver) Region(ctx context.Context, obj *model.Constellation) (*model.Region, error) <span class="cov0" title="0">{
        return universe.RegionByID(obj.RegionID)
}</span>

func (r *constellationResolver) SolarSystems(ctx context.Context, obj *model.Constellation) ([]*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByArray(obj.Systems)
}</span>

func (r *corporationResolver) Alliance(ctx context.Context, obj *model.Corporation) (*model.Alliance, error) <span class="cov0" title="0">{
        return alliance.AllianceByID(obj.AllianceID)
}</span>

func (r *corporationResolver) Ceo(ctx context.Context, obj *model.Corporation) (*model.Character, error) <span class="cov0" title="0">{
        return character.CharacterByID(obj.CeoID)
}</span>

func (r *corporationResolver) Creator(ctx context.Context, obj *model.Corporation) (*model.Character, error) <span class="cov0" title="0">{
        return character.CharacterByID(obj.CreatorID)
}</span>

func (r *corporationResolver) Faction(ctx context.Context, obj *model.Corporation) (*model.Faction, error) <span class="cov0" title="0">{
        return universe.FactionByID(obj.FactionID)
}</span>

func (r *corporationResolver) HomeStation(ctx context.Context, obj *model.Corporation) (*model.Station, error) <span class="cov0" title="0">{
        return universe.StationByID(obj.HomeStationID)
}</span>

func (r *dogma_attributeResolver) Attribute(ctx context.Context, obj *model.DogmaAttribute) (*model.DogmaAttributeDetail, error) <span class="cov0" title="0">{
        return dogma.DogmaAttributeByID(obj.AttributeID)
}</span>

func (r *dogma_effectResolver) Effect(ctx context.Context, obj *model.DogmaEffect) (*model.DogmaEffectDetail, error) <span class="cov0" title="0">{
        return dogma.DogmaEffectByID(obj.EffectID)
}</span>

func (r *dogma_effect_detailResolver) DischargeAttribute(ctx context.Context, obj *model.DogmaEffectDetail) (*model.DogmaAttributeDetail, error) <span class="cov0" title="0">{
        return dogma.DogmaAttributeByID(obj.DischargeAttributeID)
}</span>

func (r *dogma_effect_detailResolver) DurationAttribute(ctx context.Context, obj *model.DogmaEffectDetail) (*model.DogmaAttributeDetail, error) <span class="cov0" title="0">{
        return dogma.DogmaAttributeByID(obj.DurationAttributeID)
}</span>

func (r *dogma_effect_detailResolver) FalloffAttribute(ctx context.Context, obj *model.DogmaEffectDetail) (*model.DogmaAttributeDetail, error) <span class="cov0" title="0">{
        return dogma.DogmaAttributeByID(obj.FalloffAttributeID)
}</span>

func (r *dogma_effect_detailResolver) RangeAttribute(ctx context.Context, obj *model.DogmaEffectDetail) (*model.DogmaAttributeDetail, error) <span class="cov0" title="0">{
        return dogma.DogmaAttributeByID(obj.RangeAttributeID)
}</span>

func (r *dogma_effect_detailResolver) TrackingSpeedAttribute(ctx context.Context, obj *model.DogmaEffectDetail) (*model.DogmaAttributeDetail, error) <span class="cov0" title="0">{
        return dogma.DogmaAttributeByID(obj.TrackingSpeedAttributeID)
}</span>

func (r *factionResolver) Corporation(ctx context.Context, obj *model.Faction) (*model.Corporation, error) <span class="cov0" title="0">{
        return corporation.CorporationByID(obj.CorporationID)
}</span>

func (r *factionResolver) MilitiaCorporation(ctx context.Context, obj *model.Faction) (*model.Corporation, error) <span class="cov0" title="0">{
        return corporation.CorporationByID(obj.MilitiaCorporationID)
}</span>

func (r *factionResolver) SolarSystem(ctx context.Context, obj *model.Faction) (*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByID(obj.SolarSystemID)
}</span>

func (r *groupResolver) Category(ctx context.Context, obj *model.Group) (*model.Category, error) <span class="cov0" title="0">{
        return universe.CategoryByID(obj.CategoryID)
}</span>

func (r *groupResolver) ItemTypes(ctx context.Context, obj *model.Group) ([]*model.ItemType, error) <span class="cov0" title="0">{
        return universe.ItemTypesByIDs(obj.Types)
}</span>

func (r *item_typeResolver) Graphic(ctx context.Context, obj *model.ItemType) (*model.Graphic, error) <span class="cov0" title="0">{
        return universe.GraphicByID(obj.GraphicID)
}</span>

func (r *item_typeResolver) Group(ctx context.Context, obj *model.ItemType) (*model.Group, error) <span class="cov0" title="0">{
        return universe.GroupByID(obj.GroupID)
}</span>

func (r *item_typeResolver) MarketGroup(ctx context.Context, obj *model.ItemType) (*model.MarketGroup, error) <span class="cov0" title="0">{
        return market.MarketGroupByID(obj.MarketGroupID)
}</span>

func (r *market_groupResolver) ParentGroup(ctx context.Context, obj *model.MarketGroup) (*model.Group, error) <span class="cov0" title="0">{
        return universe.GroupByID(obj.ParentGroupID)
}</span>

func (r *market_groupResolver) TypesDetails(ctx context.Context, obj *model.MarketGroup) ([]*model.ItemType, error) <span class="cov0" title="0">{
        return universe.ItemTypesByIDs(obj.Types)
}</span>

func (r *modifierResolver) ModifiedAttribute(ctx context.Context, obj *model.Modifier) (*model.DogmaAttributeDetail, error) <span class="cov0" title="0">{
        return dogma.DogmaAttributeByID(obj.ModifiedAttributeID)
}</span>

func (r *modifierResolver) ModifyingAttribute(ctx context.Context, obj *model.Modifier) (*model.DogmaAttributeDetail, error) <span class="cov0" title="0">{
        return dogma.DogmaAttributeByID(obj.ModifyingAttributeID)
}</span>

func (r *moonResolver) System(ctx context.Context, obj *model.Moon) (*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByID(obj.SystemID)
}</span>

func (r *orderResolver) Location(ctx context.Context, obj *model.Order) (*model.Station, error) <span class="cov0" title="0">{
        return universe.StationByID(obj.LocationID)
}</span>

func (r *orderResolver) System(ctx context.Context, obj *model.Order) (*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByID(obj.SystemID)
}</span>

func (r *orderResolver) ItemType(ctx context.Context, obj *model.Order) (*model.ItemType, error) <span class="cov0" title="0">{
        return universe.ItemTypeByID(obj.TypeID)
}</span>

func (r *planetResolver) System(ctx context.Context, obj *model.Planet) (*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByID(obj.SystemID)
}</span>

func (r *planetResolver) ItemType(ctx context.Context, obj *model.Planet) (*model.ItemType, error) <span class="cov0" title="0">{
        return universe.ItemTypeByID(obj.TypeID)
}</span>

func (r *queryResolver) OrdersForRegion(ctx context.Context, regionID int, orderType model.Ordertype, typeID *int, page int) (*model.OrderWrapper, error) <span class="cov0" title="0">{
        return market.OrdersForRegion(&amp;regionID, &amp;orderType, typeID, &amp;page)
}</span>

func (r *queryResolver) OrdersForRegionByName(ctx context.Context, region string, orderType model.Ordertype, typeName *string, page int) (*model.OrderWrapper, error) <span class="cov0" title="0">{
        return market.OrdersForRegionByName(&amp;region, &amp;orderType, typeName, &amp;page)
}</span>

func (r *queryResolver) SystemByID(ctx context.Context, id *int) (*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByID(id)
}</span>

func (r *queryResolver) StationByID(ctx context.Context, id *int) (*model.Station, error) <span class="cov0" title="0">{
        return universe.StationByID(id)
}</span>

func (r *queryResolver) PlanetByID(ctx context.Context, id *int) (*model.Planet, error) <span class="cov0" title="0">{
        return universe.PlanetByID(id)
}</span>

func (r *queryResolver) CorporationByID(ctx context.Context, id *int) (*model.Corporation, error) <span class="cov0" title="0">{
        return corporation.CorporationByID(id)
}</span>

func (r *queryResolver) FactionByID(ctx context.Context, id *int) (*model.Faction, error) <span class="cov0" title="0">{
        return universe.FactionByID(id)
}</span>

func (r *queryResolver) OrderHistory(ctx context.Context, regionID *int, typeID *int) ([]*model.OrderHistory, error) <span class="cov0" title="0">{
        return market.OrderHistory(regionID, typeID)
}</span>

func (r *regionResolver) ConstellationList(ctx context.Context, obj *model.Region) ([]*model.Constellation, error) <span class="cov0" title="0">{
        return universe.ConstellationsByIDs(obj.Constellations)
}</span>

func (r *starResolver) SolarSystem(ctx context.Context, obj *model.Star) (*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByID(obj.SolarSystemID)
}</span>

func (r *starResolver) ItemType(ctx context.Context, obj *model.Star) (*model.ItemType, error) <span class="cov0" title="0">{
        return universe.ItemTypeByID(obj.TypeID)
}</span>

func (r *stargateResolver) ItemType(ctx context.Context, obj *model.Stargate) (*model.ItemType, error) <span class="cov0" title="0">{
        return universe.ItemTypeByID(obj.TypeID)
}</span>

func (r *stargateDestinationResolver) Stargate(ctx context.Context, obj *model.StargateDestination) (*model.Stargate, error) <span class="cov0" title="0">{
        return universe.StargateByID(obj.StargateID)
}</span>

func (r *stargateDestinationResolver) System(ctx context.Context, obj *model.StargateDestination) (*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByID(obj.SystemID)
}</span>

func (r *stationResolver) OwningCorporation(ctx context.Context, obj *model.Station) (*model.Corporation, error) <span class="cov0" title="0">{
        return corporation.CorporationByID(obj.Owner)
}</span>

func (r *stationResolver) Race(ctx context.Context, obj *model.Station) (*model.Race, error) <span class="cov0" title="0">{
        return universe.RaceByID(obj.RaceID)
}</span>

func (r *stationResolver) System(ctx context.Context, obj *model.Station) (*model.System, error) <span class="cov0" title="0">{
        return universe.SystemByID(obj.SystemID)
}</span>

func (r *stationResolver) StationType(ctx context.Context, obj *model.Station) (*model.ItemType, error) <span class="cov0" title="0">{
        return universe.ItemTypeByID(obj.TypeID)
}</span>

func (r *systemResolver) Constellation(ctx context.Context, obj *model.System) (*model.Constellation, error) <span class="cov0" title="0">{
        return universe.ConstellationByID(obj.ConstellationID)
}</span>

func (r *systemResolver) Star(ctx context.Context, obj *model.System) (*model.Star, error) <span class="cov0" title="0">{
        return universe.StarByID(obj.StarID)
}</span>

func (r *systemResolver) StargateList(ctx context.Context, obj *model.System) ([]*model.Stargate, error) <span class="cov0" title="0">{
        return universe.StargateDetails(obj.Stargates)
}</span>

func (r *systemResolver) StationList(ctx context.Context, obj *model.System) ([]*model.Station, error) <span class="cov0" title="0">{
        return universe.StationByArray(obj.Stations)
}</span>

func (r *system_planetResolver) AsteroidBeltsProperties(ctx context.Context, obj *model.SystemPlanet) ([]*model.AsteroidBelt, error) <span class="cov0" title="0">{
        return universe.AsteroidBeltDetails(obj.AsteroidBelts)
}</span>

func (r *system_planetResolver) MoonDetails(ctx context.Context, obj *model.SystemPlanet) ([]*model.Moon, error) <span class="cov0" title="0">{
        return universe.MoonDetails(obj.Moons)
}</span>

func (r *system_planetResolver) PlanetProperties(ctx context.Context, obj *model.SystemPlanet) (*model.Planet, error) <span class="cov0" title="0">{
        return universe.PlanetByID(obj.PlanetID)
}</span>

// Alliance returns generated.AllianceResolver implementation.
func (r *Resolver) Alliance() generated.AllianceResolver <span class="cov0" title="0">{ return &amp;allianceResolver{r} }</span>

// Ancestry returns generated.AncestryResolver implementation.
func (r *Resolver) Ancestry() generated.AncestryResolver <span class="cov0" title="0">{ return &amp;ancestryResolver{r} }</span>

// Asteroid_belt returns generated.Asteroid_beltResolver implementation.
func (r *Resolver) Asteroid_belt() generated.Asteroid_beltResolver <span class="cov0" title="0">{ return &amp;asteroid_beltResolver{r} }</span>

// Character returns generated.CharacterResolver implementation.
func (r *Resolver) Character() generated.CharacterResolver <span class="cov0" title="0">{ return &amp;characterResolver{r} }</span>

// Constellation returns generated.ConstellationResolver implementation.
func (r *Resolver) Constellation() generated.ConstellationResolver <span class="cov0" title="0">{ return &amp;constellationResolver{r} }</span>

// Corporation returns generated.CorporationResolver implementation.
func (r *Resolver) Corporation() generated.CorporationResolver <span class="cov0" title="0">{ return &amp;corporationResolver{r} }</span>

// Dogma_attribute returns generated.Dogma_attributeResolver implementation.
func (r *Resolver) Dogma_attribute() generated.Dogma_attributeResolver <span class="cov0" title="0">{
        return &amp;dogma_attributeResolver{r}
}</span>

// Dogma_effect returns generated.Dogma_effectResolver implementation.
func (r *Resolver) Dogma_effect() generated.Dogma_effectResolver <span class="cov0" title="0">{ return &amp;dogma_effectResolver{r} }</span>

// Dogma_effect_detail returns generated.Dogma_effect_detailResolver implementation.
func (r *Resolver) Dogma_effect_detail() generated.Dogma_effect_detailResolver <span class="cov0" title="0">{
        return &amp;dogma_effect_detailResolver{r}
}</span>

// Faction returns generated.FactionResolver implementation.
func (r *Resolver) Faction() generated.FactionResolver <span class="cov0" title="0">{ return &amp;factionResolver{r} }</span>

// Group returns generated.GroupResolver implementation.
func (r *Resolver) Group() generated.GroupResolver <span class="cov0" title="0">{ return &amp;groupResolver{r} }</span>

// Item_type returns generated.Item_typeResolver implementation.
func (r *Resolver) Item_type() generated.Item_typeResolver <span class="cov0" title="0">{ return &amp;item_typeResolver{r} }</span>

// Market_group returns generated.Market_groupResolver implementation.
func (r *Resolver) Market_group() generated.Market_groupResolver <span class="cov0" title="0">{ return &amp;market_groupResolver{r} }</span>

// Modifier returns generated.ModifierResolver implementation.
func (r *Resolver) Modifier() generated.ModifierResolver <span class="cov0" title="0">{ return &amp;modifierResolver{r} }</span>

// Moon returns generated.MoonResolver implementation.
func (r *Resolver) Moon() generated.MoonResolver <span class="cov0" title="0">{ return &amp;moonResolver{r} }</span>

// Order returns generated.OrderResolver implementation.
func (r *Resolver) Order() generated.OrderResolver <span class="cov0" title="0">{ return &amp;orderResolver{r} }</span>

// Planet returns generated.PlanetResolver implementation.
func (r *Resolver) Planet() generated.PlanetResolver <span class="cov0" title="0">{ return &amp;planetResolver{r} }</span>

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver <span class="cov0" title="0">{ return &amp;queryResolver{r} }</span>

// Region returns generated.RegionResolver implementation.
func (r *Resolver) Region() generated.RegionResolver <span class="cov0" title="0">{ return &amp;regionResolver{r} }</span>

// Star returns generated.StarResolver implementation.
func (r *Resolver) Star() generated.StarResolver <span class="cov0" title="0">{ return &amp;starResolver{r} }</span>

// Stargate returns generated.StargateResolver implementation.
func (r *Resolver) Stargate() generated.StargateResolver <span class="cov0" title="0">{ return &amp;stargateResolver{r} }</span>

// StargateDestination returns generated.StargateDestinationResolver implementation.
func (r *Resolver) StargateDestination() generated.StargateDestinationResolver <span class="cov0" title="0">{
        return &amp;stargateDestinationResolver{r}
}</span>

// Station returns generated.StationResolver implementation.
func (r *Resolver) Station() generated.StationResolver <span class="cov0" title="0">{ return &amp;stationResolver{r} }</span>

// System returns generated.SystemResolver implementation.
func (r *Resolver) System() generated.SystemResolver <span class="cov0" title="0">{ return &amp;systemResolver{r} }</span>

// System_planet returns generated.System_planetResolver implementation.
func (r *Resolver) System_planet() generated.System_planetResolver <span class="cov0" title="0">{ return &amp;system_planetResolver{r} }</span>

type allianceResolver struct{ *Resolver }
type ancestryResolver struct{ *Resolver }
type asteroid_beltResolver struct{ *Resolver }
type characterResolver struct{ *Resolver }
type constellationResolver struct{ *Resolver }
type corporationResolver struct{ *Resolver }
type dogma_attributeResolver struct{ *Resolver }
type dogma_effectResolver struct{ *Resolver }
type dogma_effect_detailResolver struct{ *Resolver }
type factionResolver struct{ *Resolver }
type groupResolver struct{ *Resolver }
type item_typeResolver struct{ *Resolver }
type market_groupResolver struct{ *Resolver }
type modifierResolver struct{ *Resolver }
type moonResolver struct{ *Resolver }
type orderResolver struct{ *Resolver }
type planetResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type regionResolver struct{ *Resolver }
type starResolver struct{ *Resolver }
type stargateResolver struct{ *Resolver }
type stargateDestinationResolver struct{ *Resolver }
type stationResolver struct{ *Resolver }
type systemResolver struct{ *Resolver }
type system_planetResolver struct{ *Resolver }
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "embed"
        "html/template"
        "net/http"
        "os"

        log "github.com/sirupsen/logrus"

        "github.com/99designs/gqlgen/graphql/handler"
        "github.com/99designs/gqlgen/graphql/playground"
        "github.com/cryanbrow/eve-graphql-go/graph"
        "github.com/cryanbrow/eve-graphql-go/graph/caching"
        "github.com/cryanbrow/eve-graphql-go/graph/configuration"
        "github.com/cryanbrow/eve-graphql-go/graph/data_access/esi/universe"
        "github.com/cryanbrow/eve-graphql-go/graph/generated"
        "github.com/cryanbrow/eve-graphql-go/graph/helpers"
)

var (
        //go:embed voyager
        res   embed.FS
        pages = map[string]string{
                "/voyager": "voyager/index.html",
        }
)

func main() <span class="cov0" title="0">{
        setupDependencies()
        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = configuration.AppConfig.Server.Port
        }</span>

        <span class="cov0" title="0">srv := handler.NewDefaultServer(generated.NewExecutableSchema(generated.Config{Resolvers: &amp;graph.Resolver{}}))

        http.Handle("/", playground.Handler("GraphQL playground", "/query"))
        http.Handle("/query", srv)

        http.HandleFunc("/voyager", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                page, ok := pages[r.URL.Path]
                if !ok </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">template, err := template.ParseFS(res, page)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("page %s not found in pages cache...", r.RequestURI)
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">w.Header().Set("Content-Type", "text/html")
                w.WriteHeader(http.StatusOK)
                data := map[string]interface{}{
                        "userAgent": r.UserAgent(),
                }
                if err := template.Execute(w, data); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        })
        <span class="cov0" title="0">http.FileServer(http.FS(res))

        log.Infoln("connect to http://localhost:%s/ for GraphQL playground", port)
        log.Fatalln(http.ListenAndServe(":"+port, nil))</span>
}

func setupDependencies() <span class="cov0" title="0">{
        configuration.LoadConfiguration()
        helpers.SetupRestHelper()
        caching.ConfigureRedisClient()
        universe.SetupUniverseRest()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
